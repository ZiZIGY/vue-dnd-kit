import{_ as s,c as e,o as t,aq as n}from"./chunks/framework.DpLxwoVt.js";const k=JSON.parse('{"title":"Collision Detection System","description":"","frontmatter":{},"headers":[],"relativePath":"guide/core/collision-detection.md","filePath":"guide/core/collision-detection.md"}'),a={name:"guide/core/collision-detection.md"};function l(o,i,r,h,p,c){return t(),e("div",null,i[0]||(i[0]=[n(`<h1 id="collision-detection-system" tabindex="-1">Collision Detection System <a class="header-anchor" href="#collision-detection-system" aria-label="Permalink to &quot;Collision Detection System&quot;">​</a></h1><p>The collision detection system is a core component of the @vue-dnd-kit/core library that determines when and where draggable elements interact with drop zones.</p><h2 id="how-collision-detection-works" tabindex="-1">How Collision Detection Works <a class="header-anchor" href="#how-collision-detection-works" aria-label="Permalink to &quot;How Collision Detection Works&quot;">​</a></h2><p>The collision detection system in the library consists of several key components:</p><h3 id="detection-process" tabindex="-1">Detection Process <a class="header-anchor" href="#detection-process" aria-label="Permalink to &quot;Detection Process&quot;">​</a></h3><ol><li><strong>Activation</strong>: When dragging begins, the sensor is activated</li><li><strong>Detection Loop</strong>: An animation frame loop (requestAnimationFrame) is initiated that periodically checks for collisions</li><li><strong>Detection Algorithm</strong>: An algorithm (default or custom) is applied to determine overlapping elements</li><li><strong>Validation and Filtering</strong>: Results are validated and filtered to exclude invalid interactions</li><li><strong>Result Processing</strong>: State is updated and appropriate events are triggered</li></ol><h3 id="default-detection-algorithm" tabindex="-1">Default Detection Algorithm <a class="header-anchor" href="#default-detection-algorithm" aria-label="Permalink to &quot;Default Detection Algorithm&quot;">​</a></h3><p>The built-in <code>defaultCollisionDetection</code> algorithm considers:</p><ul><li><strong>Element Overlap</strong>: Calculates the percentage of overlap between the draggable element and potential drop zones</li><li><strong>Pointer Position</strong>: Prioritizes elements under the mouse pointer</li><li><strong>Nesting Depth</strong>: Considers the nesting level when working with hierarchical structures</li><li><strong>Center Distance</strong>: When overlap percentages are similar, chooses the closest element</li></ul><h3 id="sorting-and-selection-process" tabindex="-1">Sorting and Selection Process <a class="header-anchor" href="#sorting-and-selection-process" aria-label="Permalink to &quot;Sorting and Selection Process&quot;">​</a></h3><p>The algorithm sorts potential collision zones using the following criteria:</p><ol><li><p>If the pointer is inside a zone:</p><ul><li>Priority is given to elements with greater nesting depth</li><li>Priority is given to elements containing the mouse pointer</li></ul></li><li><p>If the pointer is outside the zone:</p><ul><li>Priority is given to elements with a greater overlap percentage</li><li>When overlap percentages are close (difference ≤ 1%), the element with the closest center is selected</li></ul></li></ol><h2 id="custom-collision-detection" tabindex="-1">Custom Collision Detection <a class="header-anchor" href="#custom-collision-detection" aria-label="Permalink to &quot;Custom Collision Detection&quot;">​</a></h2><p>The library allows you to create custom collision detection algorithms for specific tasks:</p><h3 id="defining-a-custom-sensor" tabindex="-1">Defining a Custom Sensor <a class="header-anchor" href="#defining-a-custom-sensor" aria-label="Permalink to &quot;Defining a Custom Sensor&quot;">​</a></h3><p>You can replace the standard collision detection algorithm by providing a function in the parameters:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Example in simplified form</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useDraggable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  sensor: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // Your custom collision detection algorithm</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // Should return HTMLElement | HTMLElement[] | null</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> yourCustomDetectionLogic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(store);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    throttle: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Optional call frequency limit (ms)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="example-using-document-elementsfrompoint" tabindex="-1">Example: Using document.elementsFromPoint() <a class="header-anchor" href="#example-using-document-elementsfrompoint" aria-label="Permalink to &quot;Example: Using document.elementsFromPoint()&quot;">​</a></h3><p>Here&#39;s a simple example of a custom collision detection function using the browser&#39;s built-in <code>document.elementsFromPoint()</code> method:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useDraggable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  sensor: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // Get current pointer position from the store</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> store.pointerPosition.current.value?.x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">??</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> store.pointerPosition.current.value?.y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">??</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // Use the browser&#39;s native method to get all elements at the pointer position</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> elements</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">elementsFromPoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, y);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // Return all elements at that position (the library will handle filtering)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> elements.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> elements </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Add some throttling to improve performance</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    throttle: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>This example shows how you can leverage the browser&#39;s native APIs to create a simple but effective collision detection mechanism. The library will then handle filtering out invalid targets and applying group validation.</p><h3 id="what-your-detection-function-should-do" tabindex="-1">What Your Detection Function Should Do <a class="header-anchor" href="#what-your-detection-function-should-do" aria-label="Permalink to &quot;What Your Detection Function Should Do&quot;">​</a></h3><p>A custom detection function should:</p><ol><li>Receive the current drag state (store)</li><li>Perform your own collision detection logic</li><li>Return the HTML element(s) with which collision occurs, or null</li></ol><h3 id="working-with-groups" tabindex="-1">Working with Groups <a class="header-anchor" href="#working-with-groups" aria-label="Permalink to &quot;Working with Groups&quot;">​</a></h3><p>The system automatically checks group compatibility, so you don&#39;t need to handle this aspect in your custom function - the library will take care of it during the validation phase.</p><h2 id="advanced-features" tabindex="-1">Advanced Features <a class="header-anchor" href="#advanced-features" aria-label="Permalink to &quot;Advanced Features&quot;">​</a></h2><h3 id="performance-optimization" tabindex="-1">Performance Optimization <a class="header-anchor" href="#performance-optimization" aria-label="Permalink to &quot;Performance Optimization&quot;">​</a></h3><p>To ensure smooth operation with a large number of elements:</p><ul><li>Throttling is used to limit the frequency of collision checks</li><li>You can configure the check frequency via the <code>throttle</code> option</li></ul><h3 id="special-case-handling" tabindex="-1">Special Case Handling <a class="header-anchor" href="#special-case-handling" aria-label="Permalink to &quot;Special Case Handling&quot;">​</a></h3><p>The system accounts for:</p><ul><li>Dragging multiple selected elements</li><li><strong>Preventing nested drops</strong>: Automatically checks for DOM nesting relationships to prevent dropping elements into their own descendants or themselves</li><li>Validating group compatibility to check drag permissions</li><li>Prioritizing elements based on DOM hierarchy and nesting depth</li></ul><h2 id="conclusion" tabindex="-1">Conclusion <a class="header-anchor" href="#conclusion" aria-label="Permalink to &quot;Conclusion&quot;">​</a></h2><p>The collision detection system in Vue DnD Kit provides a flexible and powerful mechanism for precisely determining interactions between draggable elements. In most cases, the standard algorithm will work perfectly, but for complex cases, you can always implement your own detection logic.</p>`,35)]))}const g=s(a,[["render",l]]);export{k as __pageData,g as default};
